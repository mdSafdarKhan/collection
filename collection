Collections Framework
	The java.util package also contains one of Java’s most powerful subsystems: the Collections Framework. The Collections Framework is a sophisticated hierarchy of interfaces and classes that provide state-of-the-art technology for managing groups of objects. It merits close attention by all programmers. Prior to the Collections Framework, Java provided ad hoc classes such as Dictionary, Vector, Stack, and Properties to store and manipulate groups of objects. The Collections Framework was designed to meet several goals. First, the framework had to be high-performance. The implementations for the fundamental collections (dynamic arrays, linked lists, trees, and hash tables) are highly efficient.

	Several standard implementations (such as LinkedList, HashSet, and TreeSet) of these interfaces are provided that you may use as-is. You may also implement your own collection, if you choose. Various special-purpose implementations are created for your convenience, and some partial implementations are provided that make creating your own collection class easier. Finally, mechanisms were added that allow the integration of standard arrays into the Collections Framework.

	Algorithms are another important part of the collection mechanism. Algorithms operate on collections and are defined as static methods within the Collections class. Thus, they are available for all collections. Each collection class need not implement its own versions. The algorithms provide a standard means of manipulating collections. Another item closely associated with the Collections Framework is the Iterator interface. An iterator offers a general-purpose, standardized way of accessing the elements within a collection, one at a time. Thus, an iterator provides a means of enumerating the contents of a collection. Because each collection provides an iterator, the elements of any collection class can be accessed through the methods defined by Iterator.

	JDK 8 adds another type of iterator called a spliterator. In brief, spliterators are iterators that provide support for parallel iteration. The interfaces that support spliterators are Spliterator and several nested interfaces that support primitive types. JDK 8 also adds iterator interfaces designed for use with primitive types, such as PrimitiveIterator and PrimitiveIterator.OfDouble.
	
The Collection Interface
	Collection declares the core methods that all collections will have. These methods are summarized in Table 18-1. Because all collections implement Collection, familiarity with its methods is necessary for a clear understanding of the framework.

	boolean add(E obj) : Adds obj to the invoking collection. Returns true if obj was added to the collection. Returns false if obj is already a member of the collection and the collection does not allow duplicates.

	boolean addAll(Collection<? extends E> c) : Adds all the elements of c to the invoking collection. Returns true if the collection changed (i.e., the elements were added). Otherwise, returns false.

	void clear( ) ; Removes all elements from the invoking collection.

	boolean contains(Object obj) : Returns true if obj is an element of the invoking collection. Otherwise, returns false.

	boolean containsAll(Collection<?> c) : Returns true if the invoking collection contains all elements of c. Otherwise, returns false.

	boolean remove(Object obj) : Removes one instance of obj from the invoking collection. Returns true if the element was removed. Otherwise, returns false.

	boolean removeAll(Collection<?> c) : Removes all elements of c from the invoking collection. Returns true if the collection changed (i.e., elements were removed). Otherwise, returns false.

	default boolean removeIf(Predicate<? super E> predicate) : Removes from the invoking collection those elements that satisfy the condition specified by predicate. (Added by JDK 8.)

	boolean retainAll(Collection<?> c) : Removes all elements from the invoking collection except those in c. Returns true if the collection changed (i.e., elements were removed). Otherwise, returns false.

	Object[ ] toArray( ) : Returns an array that contains all the elements stored in the invoking collection. The array elements are copies of the collection elements.

	<T> T[ ] toArray(T array[ ]) : Returns an array that contains the elements of the invoking collection. The array elements are copies of the collection elements. If the size of array equals the number of elements, these are returned in array. If the size of array is less than the number of elements, a new array of the necessary size is allocated and returned. If the size of array is greater than the number of elements, the array element following the last collection element is set to null. An ArrayStoreException is thrown if any collection element has a type that is not a subtype of array.
	
The List Interface
	The List interface extends Collection and declares the behavior of a collection that stores a sequence of elements. Elements can be inserted or accessed by their position in the list, using a zero-based index. A list may contain duplicate elements.

The Set Interface
	The Set interface defines a set. It extends Collection and specifies the behavior of a collection that does not allow duplicate elements.

The SortedSet Interface
	The SortedSet interface extends Set and declares the behavior of a set sorted in ascending order.

The NavigableSet Interface
	The NavigableSet interface extends SortedSet and declares the behavior of a collection that supports the retrieval of elements based on the closest match to a given value or values.

The Queue Interface
	The Queue interface extends Collection and declares the behavior of a queue, which is often a first-in, first-out list. However, there are types of queues in which the ordering is based upon other criteria.

The Deque Interface
	The Deque interface extends Queue and declares the behavior of a double-ended queue. Double-ended queues can function as standard, first-in, first-out queues or as last-in, firstout stacks.

The Collection Classes
	Some of the classes provide full implementations that can be used as-is. Others are abstract, providing skeletal implementations that are used as starting points for creating concrete collections. As a general rule, the collection classes are not synchronized, but as you will see later in this chapter, it is possible to obtain synchronized versions. The core collection classes are summarized in the following table:
	
	AbstractCollection : Implements most of the Collection interface.
	
	AbstractList : Extends AbstractCollection and implements most of the List interface.
	
	AbstractQueue : Extends AbstractCollection and implements parts of the Queue interface.
	
	AbstractSequentialList : Extends AbstractList for use by a collection that uses sequential rather than random access of its elements.
	
	LinkedList : Implements a linked list by extending AbstractSequentialList.
	
	ArrayList : Implements a dynamic array by extending AbstractList.
	
	ArrayDeque : Implements a dynamic double-ended queue by extending AbstractCollection and implementing the Deque interface.
	
	AbstractSet : Extends AbstractCollection and implements most of the Set interface.
	
	EnumSet : Extends AbstractSet for use with enum elements.
	
	HashSet : Extends AbstractSet for use with a hash table.
	
	LinkedHashSet : Extends HashSet to allow insertion-order iterations.
	
	PriorityQueue : Extends AbstractQueue to support a priority-based queue.
	
	TreeSet : Implements a set stored in a tree. Extends AbstractSet.
	
The ArrayList Class
	ArrayList supports dynamic arrays that can grow as needed. In Java, standard arrays are of a fixed length. After arrays are created, they cannot grow or shrink, which means that you must know in advance how many elements an array will hold. But, sometimes, you may not know until run time precisely how large an array you need. To handle this situation, the Collections Framework defines ArrayList. In essence, an ArrayList is a variable-length array of object references. That is, an ArrayList can dynamically increase or decrease in size. Array lists are created with an initial size. When this size is exceeded, the collection is automatically enlarged. When objects are removed, the array can be shrunk.

	NOTE Dynamic arrays are also supported by the legacy class Vector, which is described later in this chapter.

	ArrayList has the constructors shown here:
		
		ArrayList( )
		ArrayList(Collection<? extends E> c)
		ArrayList(int capacity)
		
	The first constructor builds an empty array list. The second constructor builds an array list that is initialized with the elements of the collection c. The third constructor builds an array list that has the specified initial capacity. The capacity is the size of the underlying array that is used to store the elements. The capacity grows automatically as elements are added to an array list.
	
	Although the capacity of an ArrayList object increases automatically as objects are stored in it, you can increase the capacity of an ArrayList object manually by calling ensureCapacity( ). You might want to do this if you know in advance that you will be storing many more items in the collection than it can currently hold. By increasing its capacity once, at the start, you can prevent several reallocations later. Because reallocations are costly in terms of time, preventing unnecessary ones improves performance.

	Conversely, if you want to reduce the size of the array that underlies an ArrayList object so that it is precisely as large as the number of items that it is currently holding, call trimToSize( )

	Obtaining an Array from an ArrayList. When working with ArrayList, you will sometimes want to obtain an actual array that contains the contents of the list. You can do this by calling toArray( ), which is defined by Collection.Several reasons exist why you might want to convert a collection into an array, such as:
		
	• To obtain faster processing times for certain operations
	• To pass an array to a method that is not overloaded to accept a collection
	• To integrate collection-based code with legacy code that does not understand collections

The LinkedList Class
	The LinkedList class extends AbstractSequentialList and implements the List, Deque, and Queue interfaces. It provides a linked-list data structure.LinkedList has the two constructors shown here:
	
	LinkedList( )
	LinkedList(Collection<? extends E> c)

	The first constructor builds an empty linked list. The second constructor builds a linked list that is initialized with the elements of the collection c.

The HashSet Class
	HashSet extends AbstractSet and implements the Set interface. It creates a collection that uses a hash table for storage.

	As most readers likely know, a hash table stores information by using a mechanism called hashing. In hashing, the informational content of a key is used to determine a unique value, called its hash code. The hash code is then used as the index at which the data associated with the key is stored. The transformation of the key into its hash code is performed automatically—you never see the hash code itself. Also, your code can’t directly index the hash table. The advantage of hashing is that it allows the execution time of add( ), contains( ), remove( ), and size( ) to remain constant even for large sets. The following constructors are defined:
	
	HashSet( )
	HashSet(Collection<? extends E> c)
	HashSet(int capacity)
	HashSet(int capacity, float fillRatio)

	The first form constructs a default hash set. The second form initializes the hash set by using the elements of c. The third form initializes the capacity of the hash set to capacity. (The default capacity is 16.) The fourth form initializes both the capacity and the fill ratio (also called load capacity ) of the hash set from its arguments. The fill ratio must be between 0.0 and 1.0, and it determines how full the hash set can be before it is resized upward. Specifically, when the number of elements is greater than the capacity of the hash set multiplied by its fill ratio, the hash set is expanded. For constructors that do not take a fill ratio, 0.75 is used.

	HashSet does not define any additional methods beyond those provided by its superclasses and interfaces.

	It is important to note that HashSet does not guarantee the order of its elements, because the process of hashing doesn’t usually lend itself to the creation of sorted sets. If you need sorted storage, then another collection, such as TreeSet, is a better choice.

The LinkedHashSet Class
	The LinkedHashSet class extends HashSet and adds no members of its own. Its constructors parallel those in HashSet.

	LinkedHashSet maintains a linked list of the entries in the set, in the order in which they were inserted. This allows insertion-order iteration over the set. That is, when cycling through a LinkedHashSet using an iterator, the elements will be returned in the order in which they were inserted. This is also the order in which they are contained in the string returned by toString( ) when called on a LinkedHashSet object. To see the effect of LinkedHashSet, try substituting LinkedHashSet for HashSet in the preceding program.

The TreeSet Class
	TreeSet extends AbstractSet and implements the NavigableSet interface. It creates a collection that uses a tree for storage. Objects are stored in sorted, ascending order. Access and retrieval times are quite fast, which makes TreeSet an excellent choice when storing large amounts of sorted information that must be found quickly. TreeSet has the following constructors:
		
	TreeSet( )
	TreeSet(Collection<? extends E> c)
	TreeSet(Comparator<? super E> comp)
	TreeSet(SortedSet<E> ss)
		
	The first form constructs an empty tree set that will be sorted in ascending order according to the natural order of its elements. The second form builds a tree set that contains the elements of c. The third form constructs an empty tree set that will be sorted according to the comparator specified by comp. (Comparators are described later in this chapter.) The fourth form builds a tree set that contains the elements of ss.

	Because TreeSet implements the NavigableSet interface, you can use the methods defined by NavigableSet to retrieve elements of a TreeSet. For example, assuming the preceding program, the following statement uses subSet( ) to obtain a subset of ts that contains the elements between C (inclusive) and F (exclusive). It then displays the resulting set.
		
	System.out.println(ts.subSet("C", "F"));

	The output from this statement is shown here:
		
	[C, D, E]
		
The PriorityQueue Class
	PriorityQueue extends AbstractQueue and implements the Queue interface. It creates a queue that is prioritized based on the queue’s comparator. PriorityQueues are dynamic, growing as necessary. PriorityQueue defines the six constructors shown here:
		
	PriorityQueue( )
	PriorityQueue(int capacity)
	PriorityQueue(Comparator<? super E> comp) (Added by JDK 8.)
	PriorityQueue(int capacity, Comparator<? super E> comp)
	PriorityQueue(Collection<? extends E> c)
	PriorityQueue(PriorityQueue<? extends E> c)
	PriorityQueue(SortedSet<? extends E> c)

	The first constructor builds an empty queue. Its starting capacity is 11. The second constructor builds a queue that has the specified initial capacity. The third constructor specifies a comparator, and the fourth builds a queue with the specified capacity and comparator. The last three constructors create queues that are initialized with the elements of the collection passed in c. In all cases, the capacity grows automatically as elements are added.

	If no comparator is specified when a PriorityQueue is constructed, then the default comparator for the type of data stored in the queue is used. The default comparator will order the queue in ascending order. Thus, the head of the queue will be the smallest value. However, by providing a custom comparator, you can specify a different ordering scheme. For example, when storing items that include a time stamp, you could prioritize the queue such that the oldest items are first in the queue.

	You can obtain a reference to the comparator used by a PriorityQueue by calling its comparator( ) method, shown here:

	Comparator<? super E> comparator( )

	It returns the comparator. If natural ordering is used for the invoking queue, null is returned.

	One word of caution: Although you can iterate through a PriorityQueue using an iterator, the order of that iteration is undefined. To properly use a PriorityQueue, you must call methods such as offer( ) and poll( ), which are defined by the Queue interface.
	
The ArrayDeque Class
	The ArrayDeque class extends AbstractCollection and implements the Deque interface. It adds no methods of its own. ArrayDeque creates a dynamic array and has no capacity restrictions. (The Deque interface supports implementations that restrict capacity, but does not require such restrictions.). ArrayDeque defines the following constructors:
	
	ArrayDeque( )
	ArrayDeque(int size)
	ArrayDeque(Collection<? extends E> c)

	The first constructor builds an empty deque. Its starting capacity is 16. The second constructor builds a deque that has the specified initial capacity. The third constructor creates a deque that is initialized with the elements of the collection passed in c. In all cases, the capacity grows as needed to handle the elements added to the deque.
	
The EnumSet Class
	EnumSet extends AbstractSet and implements Set. It is specifically for use with elements of an enum type. It is a generic class that has this declaration:
		
	class EnumSet<E extends Enum<E>>

	Here, E specifies the elements. Notice that E must extend Enum<E>, which enforces the requirement that the elements must be of the specified enum type. EnumSet defines no constructors. Instead, it uses the factory methods shown in Table 18-7 to create objects.
	
Accessing a Collection via an Iterator
	Often, you will want to cycle through the elements in a collection. For example, you might want to display each element. One way to do this is to employ an iterator, which is an object that implements either the Iterator or the ListIterator interface. Iterator enables you to cycle through a collection, obtaining or removing elements. ListIterator extends Iterator to allow bidirectional traversal of a list, and the modification of elements. Iterator and ListIterator are generic interfaces which are declared as shown here:
	
	interface Iterator<E>
	interface ListIterator<E>

	Before you can access a collection through an iterator, you must obtain one. Each of the collection classes provides an iterator( ) method that returns an iterator to the start of the collection. By using this iterator object, you can access each element in the collection, one element at a time. In general, to use an iterator to cycle through the contents of a collection, follow these steps:
	
	1. Obtain an iterator to the start of the collection by calling the collection’s iterator( ) method.
	2. Set up a loop that makes a call to hasNext( ). Have the loop iterate as long as hasNext( ) returns true.
	3. Within the loop, obtain each element by calling next( ).

	For collections that implement List, you can also obtain an iterator by calling listIterator( ). As explained, a list iterator gives you the ability to access the collection in either the forward or backward direction and lets you modify an element. Otherwise, ListIterator is used just like Iterator.
	
The For-Each Alternative to Iterators
	If you won’t be modifying the contents of a collection or obtaining elements in reverse order, then the for-each version of the for loop is often a more convenient alternative to cycling through a collection than is using an iterator. Recall that the for can cycle through any collection of objects that implement the Iterable interface. Because all of the collection classes implement this interface, they can all be operated upon by the for.

Spliterators
	JDK 8 adds a new type of iterator called a spliterator that is defined by the Spliterator interface. A spliterator cycles through a sequence of elements, and in this regard, it is similar to the iterators just described. However, the techniques required to use it differ. Furthermore, it offers substantially more functionality than does either Iterator or ListIterator. Perhaps the most important aspect of Spliterator is its ability to provide support for parallel iteration of portions of the sequence. Thus, Spliterator supports parallel programming. (See Chapter 28 for information on concurrency and parallel programming.) However, you can use Spliterator even if you won’t be using parallel execution. One reason you might want to do so is because it offers a streamlined approach that combines the hasNext and next operations into one method.

	Using Spliterator for basic iteration tasks is quite easy: simply call tryAdvance( ) until it returns false. If you will be applying the same action to each element in the sequence, forEachRemaining( ) offers a streamlined alternative. In both cases, the action that will occur with each iteration is defined by what the Consumer object does with each element.
	
Storing User-Defined Classes in Collections
	No description....
	
The RandomAccess Interface
	Skipping for now....
	
Working with Maps
	A map is an object that stores associations between keys and values, or key/value pairs. Given a key, you can find its value. Both keys and values are objects. The keys must be unique, but the values may be duplicated. Some maps can accept a null key and null values, others cannot.

	There is one key point about maps that is important to mention at the outset: they don’t implement the Iterable interface. This means that you cannot cycle through a map using a for-each style for loop. Furthermore, you can’t obtain an iterator to a map.

The Map Interfaces
	Because the map interfaces define the character and nature of maps, this discussion of maps begins with them. The following interfaces support maps:

	Map : Maps unique keys to values.

	Map.Entry : Describes an element (a key/value pair) in a map. This is an inner class of Map.

	NavigableMap : Extends SortedMap to handle the retrieval of entries based on closest-match searches.

	SortedMap : Extends Map so that the keys are maintained in ascending order.
	
The Map Classes
	Several classes provide implementations of the map interfaces. The classes that can be used for maps are summarized here:

	AbstractMap : Implements most of the Map interface.

	EnumMap : Extends AbstractMap for use with enum keys.

	HashMap : Extends AbstractMap to use a hash table.

	TreeMap : Extends AbstractMap to use a tree.

	WeakHashMap : Extends AbstractMap to use a hash table with weak keys.

	LinkedHashMap : Extends HashMap to allow insertion-order iterations.

	IdentityHashMap : Extends AbstractMap and uses reference equality when comparing documents.
	
	Notice that AbstractMap is a superclass for all concrete map implementations. WeakHashMap implements a map that uses “weak keys,” which allows an element in a map to be garbage-collected when its key is otherwise unused. This class is not discussed further here. The other map classes are described next.
	
The HashMap Class
	The HashMap class extends AbstractMap and implements the Map interface. It uses a hash table to store the map. This allows the execution time of get( ) and put( ) to remain constant even for large sets. The following constructors are defined:
	
	HashMap( )
	HashMap(Map<? extends K, ? extends V> m)
	HashMap(int capacity)
	HashMap(int capacity, float fillRatio)

	The first form constructs a default hash map. The second form initializes the hash map by using the elements of m. The third form initializes the capacity of the hash map to capacity. The fourth form initializes both the capacity and fill ratio of the hash map by using its arguments. The meaning of capacity and fill ratio is the same as for HashSet, described earlier. The default capacity is 16. The default fill ratio is 0.75. HashMap implements Map and extends AbstractMap. It does not add any methods of its own. You should note that a hash map does not guarantee the order of its elements. Therefore, the order in which elements are added to a hash map is not necessarily the order in which they are read by an iterator.
	
The TreeMap Class
	The TreeMap class extends AbstractMap and implements the NavigableMap interface. It creates maps stored in a tree structure. A TreeMap provides an efficient means of storing key/value pairs in sorted order and allows rapid retrieval. You should note that, unlike a hash map, a tree map guarantees that its elements will be sorted in ascending key order. The following TreeMap constructors are defined:
	
	TreeMap( )
	TreeMap(Comparator<? super K> comp)
	TreeMap(Map<? extends K, ? extends V> m)
	TreeMap(SortedMap<K, ? extends V> sm)

	The first form constructs an empty tree map that will be sorted by using the natural order of its keys. The second form constructs an empty tree-based map that will be sorted by using the Comparator comp. (Comparators are discussed later in this chapter.) The third form initializes a tree map with the entries from m, which will be sorted by using the natural order of the keys. The fourth form initializes a tree map with the entries from sm, which will be sorted in the same order as sm. TreeMap has no map methods beyond those specified by the NavigableMap interface and the AbstractMap class.

The LinkedHashMap Class
	LinkedHashMap extends HashMap. It maintains a linked list of the entries in the map, in the order in which they were inserted. This allows insertion-order iteration over the map.That is, when iterating through a collection-view of a LinkedHashMap, the elements will be returned in the order in which they were inserted. You can also create a LinkedHashMap that returns its elements in the order in which they were last accessed. LinkedHashMap defines the following constructors:

	LinkedHashMap( )
	LinkedHashMap(Map<? extends K, ? extends V> m)
	LinkedHashMap(int capacity)
	LinkedHashMap(int capacity, float fillRatio)
	LinkedHashMap(int capacity, float fillRatio, boolean Order)

	The first form constructs a default LinkedHashMap. The second form initializes the LinkedHashMap with the elements from m. The third form initializes the capacity. The fourth form initializes both capacity and fill ratio. The meaning of capacity and fill ratio are the same as for HashMap. The default capacity is 16. The default ratio is 0.75. The last form allows you to specify whether the elements will be stored in the linked list by insertion order, or by order of last access. If Order is true, then access order is used. If Order is false, then insertion order is used.

	LinkedHashMap adds only one method to those defined by HashMap. This method is removeEldestEntry( ), and it is shown here:

		protected boolean removeEldestEntry(Map.Entry<K, V> e)
		
	This method is called by put( ) and putAll( ). The oldest entry is passed in e. By default, this method returns false and does nothing. However, if you override this method, then you can have the LinkedHashMap remove the oldest entry in the map. To do this, have your override return true. To keep the oldest entry, return false.
	
Comparators
	Both TreeSet and TreeMap store elements in sorted order. However, it is the comparator that defines precisely what “sorted order” means. By default, these classes store their elements by using what Java refers to as “natural ordering,” which is usually the ordering that you would expect (A before B, 1 before 2, and so forth). If you want to order elements a different way, then specify a Comparator when you construct the set or map. Doing so gives you the ability to govern precisely how elements are stored within sorted collections and maps.

	Prior to JDK 8, the Comparator interface defined only two methods: compare( ) and equals( ). The compare( ) method, shown here, compares two elements for order:

		int compare(T obj1, T obj2)

	obj1 and obj2 are the objects to be compared. Normally, this method returns zero if the objects are equal. It returns a positive value if obj1 is greater than obj2. Otherwise, a negative value is returned.

	Skipping Comaprator for now...

The Collection Algorithms
	One thing to pay special attention to is the set of checked methods, such as checkedCollection( ), which returns what the API documentation refers to as a “dynamically typesafe view” of a collection. This view is a reference to the collection that monitors insertions into the collection for type compatibility at run time. An attempt to insert an incompatible element will cause a ClassCastException. Using such a view is especially helpful during debugging because it ensures that the collection always contains valid elements. Related methods include checkedSet( ), checkedList( ), checkedMap( ), and so on. They obtain a type-safe view for the indicated collection.

	Notice that several methods, such as synchronizedList( ) and synchronizedSet( ), are used to obtain synchronized (thread-safe) copies of the various collections. As a general rule, the standard collections implementations are not synchronized. You must use the synchronization algorithms to provide synchronization. One other point: iterators to synchronized collections must be used within synchronized blocks.

	The set of methods that begins with unmodifiable returns views of the various collections that cannot be modified. These will be useful when you want to grant some process read—but not write—capabilities on a collection.

	Collections defines three static variables: EMPTY_SET, EMPTY_LIST, and EMPTY_MAP. All are immutable.

Arrays
	The Arrays class provides various methods that are useful when working with arrays. These methods help bridge the gap between collections and arrays.

	The asList( ) method returns a List that is backed by a specified array. In other words, both the list and the array refer to the same location. It has the following signature:
		static <T> List asList(T... array)

	The binarySearch( ) method uses a binary search to find a specified value. This method must be applied to sorted arrays. Here are some of its forms. (Additional forms let you search a subrange):
		static int binarySearch(byte array[ ], byte value)
		static int binarySearch(char array[ ], char value)
		static int binarySearch(double array[ ], double value)
		static int binarySearch(float array[ ], float value)
		static int binarySearch(int array[ ], int value)
		static int binarySearch(long array[ ], long value)
		static int binarySearch(short array[ ], short value)
		static int binarySearch(Object array[ ], Object value)
		static <T> int binarySearch(T[ ] array, T value, Comparator<? super T> c)

		In the last form, the Comparator c is used to determine the order of the elements in array. In all cases, if value exists in array, the index of the element is returned. Otherwise, a negative value is returned.

	The copyOf( ) method returns a copy of an array and has the following forms:
		static boolean[ ] copyOf(boolean[ ] source, int len)
		static byte[ ] copyOf(byte[ ] source, int len)
		static char[ ] copyOf(char[ ] source, int len)
		static double[ ] copyOf(double[ ] source, int len)
		static float[ ] copyOf(float[ ] source, int len)
		static int[ ] copyOf(int[ ] source, int len)
		static long[ ] copyOf(long[ ] source, int len)
		static short[ ] copyOf(short[ ] source, int len)
		static <T> T[ ] copyOf(T[ ] source, int len)
		static <T,U> T[ ] copyOf(U[ ] source, int len, Class<? extends T[ ]> resultT)

		The original array is specified by source, and the length of the copy is specified by len. If the copy is longer than source, then the copy is padded with zeros (for numeric arrays), nulls (for object arrays), or false (for boolean arrays). If the copy is shorter than source, then the copy is truncated.

	The equals( ) method returns true if two arrays are equivalent. Otherwise, it returns false. The equals( ) method has the following forms:
		static boolean equals(boolean array1[ ], boolean array2 [ ])
		static boolean equals(byte array1[ ], byte array2 [ ])
		static boolean equals(char array1[ ], char array2 [ ])
		static boolean equals(double array1[ ], double array2 [ ])
		static boolean equals(float array1[ ], float array2 [ ])
		static boolean equals(int array1[ ], int array2 [ ])
		static boolean equals(long array1[ ], long array2 [ ])
		static boolean equals(short array1[ ], short array2 [ ])
		static boolean equals(Object array1[ ], Object array2 [ ])
		
		Here, array1 and array2 are the two arrays that are compared for equality.

	The deepEquals( ) method can be used to determine if two arrays, which might contain nested arrays, are equal. It has this declaration:
	
		static boolean deepEquals(Object[ ] a, Object[ ] b)

		It returns true if the arrays passed in a and b contain the same elements. If a and b contain nested arrays, then the contents of those nested arrays are also checked. It returns false if the arrays, or any nested arrays, differ.

	The fill( ) method assigns a value to all elements in an array. In other words, it fills an array with a specified value. The fill( ) method has two versions. The first version, which has the following forms, fills an entire array:
		
		static void fill(boolean array[ ], boolean value)
		static void fill(byte array[ ], byte value)
		static void fill(char array[ ], char value)
		static void fill(double array[ ], double value)
		static void fill(float array[ ], float value)
		static void fill(int array[ ], int value)
		static void fill(long array[ ], long value)
		static void fill(short array[ ], short value)
		static void fill(Object array[ ], Object value)
	
		Here, value is assigned to all elements in array. The second version of the fill( ) method assigns a value to a subset of an array.

	The sort( ) method sorts an array so that it is arranged in ascending order. The sort( ) method has two versions. The first version, shown here, sorts the entire array:
		static void sort(byte array[ ])
		static void sort(char array[ ])
		static void sort(double array[ ])
		static void sort(float array[ ])
		static void sort(int array[ ])
		static void sort(long array[ ])
		static void sort(short array[ ])
		static void sort(Object array[ ])
		static <T> void sort(T array[ ], Comparator<? super T> c)
		
	Here, array is the array to be sorted. In the last form, c is a Comparator that is used to order the elements of array.The second version of sort( ) enables you to specify a range within an array that you want to sort.

	JDK 8 adds several new methods to Arrays. Perhaps the most important is parallelSort( ) because it sorts, into ascending order, portions of an array in parallel and then merges the results. This approach can greatly speed up sorting times. Like sort( ), there are two basic types of parallelSort( ), each with several overloads. The first type sorts the entire array. It is shown here:
	
		static void parallelSort(byte array[ ])
		static void parallelSort(char array[ ])
		static void parallelSort(double array[ ])
		static void parallelSort(float array[ ])
		static void parallelSort(int array[ ])
		static void parallelSort(long array[ ])
		static void parallelSort(short array[ ])
		static <T extends Comparable<? super T>> void parallelSort(T array[ ])
		static <T> void parallelSort(T array[ ], Comparator<? super T> c)

		Here, array is the array to be sorted. In the last form, c is a comparator that is used to order the elements in the array.The second version of parallelSort( ) enables you to specify a range within the array that you want to sort.

	Beginning with JDK 8, Arrays supports the new Stream interface (see Chapter 29) by including the stream( ) method. It has two forms. The first is shown here:
		
		static DoubleStream stream(double array[ ])
		static IntStream stream(int array[ ])
		static LongStream stream(long array[ ])
		static <T> Stream stream(T array[ ])
		
		Here, array is the array to which the stream will refer. The second version of stream( ) enables you to specify a range within the array.

The Legacy Classes and Interfaces
	One other point: none of the modern collection classes described in this chapter are synchronized, but all the legacy classes are synchronized.This distinction may be important in some situations. Of course, you can easily synchronize collections by using one of the algorithms provided by Collections.

Vector
	Vector implements a dynamic array. It is similar to ArrayList, but with two differences: Vector is synchronized, and it contains many legacy methods that duplicate the functionality of methods defined by the Collections Framework. With the advent of collections, Vector was reengineered to extend AbstractList and to implement the List interface. With the release of JDK 5, it was retrofitted for generics and reengineered to implement Iterable. This means that Vector is fully compatible with collections, and a Vector can have its contents iterated by the enhanced for loop. Here are the Vector constructors:
		
		Vector( )
		Vector(int size)
		Vector(int size, int incr)
		Vector(Collection<? extends E> c)

	The first form creates a default vector, which has an initial size of 10. The second form creates a vector whose initial capacity is specified by size. The third form creates a vector whose initial capacity is specified by size and whose increment is specified by incr. The increment specifies the number of elements to allocate each time that a vector is resized upward. The fourth form creates a vector that contains the elements of collection c.

	All vectors start with an initial capacity. After this initial capacity is reached, the next time that you attempt to store an object in the vector, the vector automatically allocates space for that object plus extra room for additional objects. By allocating more than just the required memory, the vector reduces the number of allocations that must take place as the vector grows. This reduction is important, because allocations are costly in terms of time. The amount of extra space allocated during each reallocation is determined by the increment that you specify when you create the vector. If you don’t specify an increment, the vector’s size is doubled by each allocation cycle.

Stack
	Stack is a subclass of Vector that implements a standard last-in, first-out stack. Stack includes all the methods defined by Vector and adds several of its own like: 
		boolean empty( )  : Returns true if the stack is empty, and returns false if the stack contains elements.

		E peek( ) : Returns the element on the top of the stack, but does not remove it.
		
		E pop( ) : Returns the element on the top of the stack, removing it in the process.
		
		E push(E element) : Pushes element onto the stack. element is also returned.
		
		int search(Object element) : Searches for element in the stack. If found, its offset from the top of the stack is returned. Otherwise, –1 is returned.

	One other point: although Stack is not deprecated, ArrayDeque is a better choice.

Dictionary
	Dictionary is an abstract class that represents a key/value storage repository and operates much like Map. Given a key and value, you can store the value in a Dictionary object. Once the value is stored, you can retrieve it by using its key. Thus, like a map, a dictionary can be thought of as a list of key/value pairs. Although not currently deprecated, Dictionary is classified as obsolete, because it is fully superseded by Map.

Hashtable
	Hashtable was part of the original java.util and is a concrete implementation of a Dictionary. However, with the advent of collections, Hashtable was reengineered to also implement the Map interface. Thus, Hashtable is integrated into the Collections Framework. It is similar to HashMap, but is synchronized.

	Like HashMap, Hashtable stores key/value pairs in a hash table. However, neither keys nor values can be null. When using a Hashtable, you specify an object that is used as a key, and the value that you want linked to that key. The key is then hashed, and the resulting hash code is used as the index at which the value is stored within the table.

	A hash table can only store objects that override the hashCode( ) and equals( ) methods that are defined by Object. The hashCode( ) method must compute and return the hash code for the object. Of course, equals( ) compares two objects. Fortunately, many of Java’s built-in classes already implement the hashCode( ) method. For example, the most common type of Hashtable uses a String object as the key. String implements both hashCode( ) and equals( ). The Hashtable constructors are shown here:

		Hashtable( )
		Hashtable(int size)
		Hashtable(int size, float fillRatio)
		Hashtable(Map<? extends K, ? extends V> m)

	The first version is the default constructor. The second version creates a hash table that has an initial size specified by size. (The default size is 11.) The third version creates a hash table that has an initial size specified by size and a fill ratio specified by fillRatio. This ratio must be between 0.0 and 1.0, and it determines how full the hash table can be before it is resized upward. Specifically, when the number of elements is greater than the capacity of the hash table multiplied by its fill ratio, the hash table is expanded. If you do not specify a fill ratio, then 0.75 is used. Finally, the fourth version creates a hash table that is initialized with the elements in m. The default load factor of 0.75 is used.

Properties
	Properties is a subclass of Hashtable. It is used to maintain lists of values in which the key is a String and the value is also a String. The Properties class is used by some other Java classes. For example, it is the type of object returned by System.getProperties( ) when obtaining environmental values. Although the Properties class, itself, is not generic, several of its methods are.Properties defines these constructors:
		
		Properties( )
		Properties(Properties propDefault)
		
	The first version creates a Properties object that has no default values. The second creates an object that uses propDefault for its default values. In both cases, the property list is empty.

	Using store( ) and load( ): One of the most useful aspects of Properties is that the information contained in a Properties object can be easily stored to or loaded from disk with the store( ) and load( ) methods. At any time, you can write a Properties object to a stream or read it back. This makes property lists especially convenient for implementing simple databases.